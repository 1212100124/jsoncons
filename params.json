{
  "name": "Jsoncons",
  "tagline": "C++ library for parsing and serializing JSON text",
  "body": "# jsoncons: a C++ library for json construction\r\n\r\njsoncons is a C++ library for the construction of [JavaScript Object Notation (JSON)](http://www.json.org). It supports parsing a JSON file or string into a `json` value, building a `json` value in C++ code, and serializing a `json` value to a file or string. It supports converting to and from the standard library sequence and associative containers. It also provides an API for generating json read and write events in code, somewhat analogously to SAX processing in the XML world. Consult the wiki for the latest [documentation and tutorials](https://github.com/danielaparker/jsoncons/wiki) and [roadmap](https://github.com/danielaparker/jsoncons/wiki/Roadmap). \r\n\r\njsoncons uses some features that are new to C++ 11, particularly [move semantics](http://thbecker.net/articles/rvalue_references/section_02.html) and the [AllocatorAwareContainer](http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer) concept. It has been tested with MS VC++ 2013, MS VC++ 2015, GCC 4.8, GCC 4.9, and recent versions of clang. Note that `std::regex` isn't fully implemented in GCC 4.8., so `jsoncons_ext/jsonpath` regular expression filters aren't supported for that compiler.\r\n\r\n## Using the jsoncons library\r\n\r\nThe jsoncons library is header-only: it consists solely of header files containing templates and inline functions, and requires no separately-compiled library binaries when linking. It has no dependence on other libraries. \r\n\r\nTo install the jsoncons library, download the zip file, extract the zipped files, look under `src` for the directory `jsoncons`, and copy it to your `include` directory. If you wish to use extensions, copy the `jsoncons_ext` directory as well. \r\n\r\nThe jsoncons classes and functions are in namespace `jsoncons`. You need to include the header file\r\n```c++ \r\n#include <jsoncons/json.hpp>\r\n```\r\nand, for convenience,\r\n\r\n    using jsoncons::json;\r\n\r\n### Reading JSON text from a file\r\n\r\nHere is a sample file, `books.json`:\r\n```c++\r\n[\r\n    {\r\n        \"title\" : \"Kafka on the Shore\",\r\n        \"author\" : \"Haruki Murakami\",\r\n        \"price\" : 25.17\r\n    },\r\n    {\r\n        \"title\" : \"Women: A Novel\",\r\n        \"author\" : \"Charles Bukowski\",\r\n        \"price\" : 12.0\r\n    },\r\n    {\r\n        \"title\" : \"Cutter's Way\",\r\n        \"author\" : \"Ivan Passer\"\r\n    }\r\n]\r\n```\r\nIt consists of an array of book elements, each element is an object with members title, author, and price.\r\n\r\nRead the JSON text into a `json` value,\r\n```c++\r\nstd::ifstream is(\"books.json\");\r\njson books;\r\nis >> books;\r\n```\r\nLoop through the book array elements, using a range-based for loop\r\n```c++\r\nfor (const auto& book : books.array_range())\r\n{\r\n    std::string author = book[\"author\"].as<std::string>();\r\n    std::string title = book[\"title\"].as<std::string>();\r\n    std::cout << author << \", \" << title << std::endl;\r\n}\r\n```\r\nor begin-end iterators\r\n```c++\r\nfor (auto it = books.array_range().begin(); \r\n     it != books.array_range().end();\r\n     ++it)\r\n{\r\n    std::string author = (*it)[\"author\"].as<std::string>();\r\n    std::string title = (*it)[\"title\"].as<std::string>();\r\n    std::cout << author << \", \" << title << std::endl;\r\n} \r\n```\r\nor a traditional for loop\r\n```c++\r\nfor (size_t i = 0; i < books.size(); ++i)\r\n{\r\n    json& book = books[i];\r\n    std::string author = book[\"author\"].as<std::string>();\r\n    std::string title = book[\"title\"].as<std::string>();\r\n    std::cout << author << \", \" << title << std::endl;\r\n}\r\n```\r\nOutput:\r\n```\r\nHaruki Murakami, Kafka on the Shore\r\nCharles Bukowski, Women: A Novel\r\nIvan Passer, Cutter's Way\r\n```\r\n\r\nLoop through the members of the third book element, using a range-based for loop\r\n\r\n```c++\r\nfor (const auto& member : books[2].object_range())\r\n{\r\n    std::cout << member.key() << \"=\" \r\n              << member.value() << std::endl;\r\n}\r\n```\r\n\r\nor begin-end iterators:\r\n\r\n```c++\r\nfor (auto it = books[2].object_range().begin(); \r\n     it != books[2].object_range().end();\r\n     ++it)\r\n{\r\n    std::cout << (*it).key() << \"=\" \r\n              << (*it).value() << std::endl;\r\n} \r\n```\r\nOutput:\r\n```\r\nauthor=Ivan Passer\r\ntitle=Cutter's Way\r\n```\r\n\r\nNote that the third book, Cutter's Way, is missing a price.\r\n\r\nYou have a choice of object member accessors:\r\n\r\n- `book[\"price\"]` will throw `std::out_of_range` if there is no price\r\n- `book.get_with_default(\"price\",\"n/a\")` will return the price converted to the default's data type, or \"n/a\" if there is no price.\r\n\r\nSo if you want to show \"n/a\" for the missing price, you can use this accessor\r\n```c++\r\nstd::string price = book.get_with_default(\"price\",\"n/a\");\r\n```\r\nOr you can check if book has a member \"price\" with the method `has_key`, and output accordingly,\r\n```c++\r\nif (book.has_key(\"price\"))\r\n{\r\n    double price = book[\"price\"].as<double>();\r\n    std::cout << price;\r\n}\r\nelse\r\n{\r\n    std::cout << \"n/a\";\r\n}\r\n```\r\n### Constructing json values in C++\r\n\r\nThe default `json` constructor produces an empty json object. For example \r\n```c++\r\njson image_sizing;\r\nstd::cout << image_sizing << std::endl;\r\n```\r\nproduces\r\n```json\r\n{}\r\n```\r\nTo construct a json object with members, take an empty json object and set some name-value pairs\r\n```c++\r\nimage_sizing.set(\"Resize To Fit\",true);  // a boolean \r\nimage_sizing.set(\"Resize Unit\", \"pixels\");  // a string\r\nimage_sizing.set(\"Resize What\", \"long_edge\");  // a string\r\nimage_sizing.set(\"Dimension 1\",9.84);  // a double\r\nimage_sizing.set(\"Dimension 2\",json::null());  // a null value\r\n```\r\n\r\nOr, use an object initializer-list:\r\n```c++\r\njson file_settings = json::object{\r\n    {\"Image Format\", \"JPEG\"},\r\n    {\"Color Space\", \"sRGB\"},\r\n    {\"Limit File Size\", true},\r\n    {\"Limit File Size To\", 10000}\r\n};\r\n```\r\n\r\nTo construct a json array, initialize with the array type \r\n```c++\r\njson color_spaces = json::array();\r\n```\r\nand add some elements\r\n```c++\r\ncolor_spaces.add(\"sRGB\");\r\ncolor_spaces.add(\"AdobeRGB\");\r\ncolor_spaces.add(\"ProPhoto RGB\");\r\n```\r\n\r\nOr, use an array initializer-list:\r\n```c++\r\njson image_formats = json::array{\"JPEG\",\"PSD\",\"TIFF\",\"DNG\"};\r\n```\r\n\r\nThe `operator[]` provides another way for setting name-value pairs.\r\n```c++\r\njson file_export;\r\nfile_export[\"File Format Options\"][\"Color Spaces\"] = \r\n    std::move(color_spaces);\r\nfile_export[\"File Format Options\"][\"Image Formats\"] = \r\n    std::move(image_formats);\r\nfile_export[\"File Settings\"] = std::move(file_settings);\r\nfile_export[\"Image Sizing\"] = std::move(image_sizing);\r\n```\r\nNote that if `file_export[\"File Format Options\"]` doesn't exist, \r\n```c++\r\nfile_export[\"File Format Options\"][\"Color Spaces\"] = \r\n    std::move(color_spaces)\r\n```\r\ncreates `\"File Format Options\"` as an object and puts `\"Color Spaces\"` in it.\r\n\r\nSerializing\r\n```c++\r\nstd::cout << pretty_print(file_export) << std::endl;\r\n```\r\nproduces\r\n```json\r\n{\r\n    \"File Format Options\": {\r\n        \"Color Spaces\": [\"sRGB\",\"AdobeRGB\",\"ProPhoto RGB\"],\r\n        \"Image Formats\": [\"JPEG\",\"PSD\",\"TIFF\",\"DNG\"]\r\n    },\r\n    \"File Settings\": {\r\n        \"Color Space\": \"sRGB\",\r\n        \"Image Format\": \"JPEG\",\r\n        \"Limit File Size\": true,\r\n        \"Limit File Size To\": 10000\r\n    },\r\n    \"Image Sizing\": {\r\n        \"Dimension 1\": 9.84,\r\n        \"Dimension 2\": null,\r\n        \"Resize To Fit\": true,\r\n        \"Resize Unit\": \"pixels\",\r\n        \"Resize What\": \"long_edge\"\r\n    }\r\n}\r\n```\r\n### Converting to and from standard library containers\r\n\r\nThe jsoncons library supports converting to and from the standard library sequence and associative containers.\r\n\r\n```c++\r\nstd::vector<int> v = {1,2,3,4};\r\njson j(v);\r\nstd::cout << j << std::endl;\r\n```\r\nOutput:\r\n```json\r\n[1,2,3,4]\r\n```\r\n\r\n```c++\r\njson j = json::array{1,true,\"last\"};\r\nauto d = j.as<std::deque<std::string>>();\r\nfor (auto x : d)\r\n{\r\n    std::cout << x << std::endl;\r\n}\r\n```\r\nOutput:\r\n```\r\n1\r\ntrue\r\nlast\r\n```\r\n\r\n```c++\r\nstd::map<std::string,int> m = {{\"one\",1},{\"two\",2},{\"three\",3}};\r\njson j(m);\r\nstd::cout << j << std::endl;\r\n```\r\nOutput:\r\n```json\r\n{\"one\":1,\"three\":3,\"two\":2}\r\n```\r\n\r\n```c++\r\njson j;\r\nj[\"one\"] = 1;\r\nj[\"two\"] = 2;\r\nj[\"three\"] = 3;\r\n\r\nauto um = j.as<std::unordered_map<std::string,int>>();\r\nfor (const auto& x : um)\r\n{\r\n    std::cout << x.first << \"=\" << x.second << std::endl;\r\n}\r\n```\r\nOutput:\r\n```\r\none=1\r\nthree=3\r\ntwo=2\r\n```\r\n\r\n### Converting CSV files to json\r\n\r\nHere is a sample CSV file (tasks.csv):\r\n```\r\nproject_id, task_name, task_start, task_finish\r\n4001,task1,01/01/2003,01/31/2003\r\n4001,task2,02/01/2003,02/28/2003\r\n4001,task3,03/01/2003,03/31/2003\r\n4002,task1,04/01/2003,04/30/2003\r\n4002,task2,05/01/2003,\r\n```\r\nYou can read the `CSV` file into a `json` value with the `csv_reader`.\r\n```c++\r\n#include <jsoncons_ext/csv/csv_reader.hpp>\r\n\r\nusing jsoncons::csv::csv_parameters;\r\nusing jsoncons::csv::csv_reader;\r\nusing jsoncons::json_encoder;\r\n\r\nstd::fstream is(\"tasks.csv\");\r\n\r\njson_encoder<json> encoder;\r\n\r\ncsv_parameters params;\r\nparams.assume_header(true)\r\n      .trim(true)\r\n      .ignore_empty_values(true)\r\n      .column_types({\"integer\",\"string\",\"string\",\"string\"});\r\n\r\ncsv_reader reader(is,encoder,params);\r\nreader.read();\r\njson val = encoder.get_result();\r\n\r\nstd::cout << pretty_print(val) << std::endl;\r\n```\r\nOutput:\r\n```json\r\n[\r\n    {\r\n        \"project_id\":4001,\r\n        \"task_finish\":\"01/31/2003\",\r\n        \"task_name\":\"task1\",\r\n        \"task_start\":\"01/01/2003\"\r\n    },\r\n    {\r\n        \"project_id\":4001,\r\n        \"task_finish\":\"02/28/2003\",\r\n        \"task_name\":\"task2\",\r\n        \"task_start\":\"02/01/2003\"\r\n    },\r\n    {\r\n        \"project_id\":4001,\r\n        \"task_finish\":\"03/31/2003\",\r\n        \"task_name\":\"task3\",\r\n        \"task_start\":\"03/01/2003\"\r\n    },\r\n    {\r\n        \"project_id\":4002,\r\n        \"task_finish\":\"04/30/2003\",\r\n        \"task_name\":\"task1\",\r\n        \"task_start\":\"04/01/2003\"\r\n    },\r\n    {\r\n        \"project_id\":4002,\r\n        \"task_name\":\"task2\",\r\n        \"task_start\":\"05/01/2003\"\r\n    }\r\n]\r\n```\r\nThere are a few things to note about the effect of the parameter settings.\r\n- `assume_header` `true` tells the csv parser to parse the first line of the file for column names, which become object member names.\r\n- `trim` `true` tells the parser to trim leading and trailing whitespace, in particular, to remove the leading whitespace in the column names.\r\n- `ignore_empty_values` `true` causes the empty last value in the `task_finish` column to be omitted.\r\n- The `column_types` setting specifies that column one (\"project_id\") contains integers and the remaining columns strings.\r\n\r\n### Pretty print\r\n\r\nThe `pretty_print` function applies stylistic formatting to JSON text. For example\r\n\r\n```c++\r\n    json val;\r\n\r\n    val[\"verts\"] = json::array{1, 2, 3};\r\n    val[\"normals\"] = json::array{1, 0, 1};\r\n    val[\"uvs\"] = json::array{0, 0, 1, 1};\r\n\r\n    std::cout << pretty_print(val) << std::endl;\r\n```\r\nproduces\r\n\r\n```json\r\n{\r\n    \"normals\": [1,0,1],\r\n    \"uvs\": [0,0,1,1],\r\n    \"verts\": [1,2,3]\r\n}\r\n```\r\nBy default, within objects, arrays of scalar values are displayed on the same line.\r\n\r\nThe `pretty_print` function takes an optional second parameter, [serialization_options](https://github.com/danielaparker/jsoncons/wiki/serialization_options), that allows custom formatting of output.\r\nTo display the array scalar values on a new line, set the `object_array_split_lines` property to `line_split_kind::new_line`. The code\r\n```c++\r\nserialization_options format;\r\nformat.object_array_split_lines(line_split_kind::new_line);\r\nstd::cout << pretty_print(val,format) << std::endl;\r\n```\r\nproduces\r\n```json\r\n{\r\n    \"normals\": [\r\n        1,0,1\r\n    ],\r\n    \"uvs\": [\r\n        0,0,1,1\r\n    ],\r\n    \"verts\": [\r\n        1,2,3\r\n    ]\r\n}\r\n```\r\nTo display the elements of array values on multiple lines, set the `object_array_split_lines` property to `line_split_kind::multi_line`. The code\r\n```c++\r\nserialization_options format;\r\nformat.object_array_split_lines(line_split_kind::multi_line);\r\nstd::cout << pretty_print(val,format) << std::endl;\r\n```\r\nproduces\r\n```json\r\n{\r\n    \"normals\": [\r\n        1,\r\n        0,\r\n        1\r\n    ],\r\n    \"uvs\": [\r\n        0,\r\n        0,\r\n        1,\r\n        1\r\n    ],\r\n    \"verts\": [\r\n        1,\r\n        2,\r\n        3\r\n    ]\r\n}\r\n```\r\n\r\n### Filters\r\n\r\nYou can rename object member names with the built in filter [rename_name_filter](https://github.com/danielaparker/jsoncons/wiki/rename_name_filter)\r\n\r\n```c++\r\n#include <sstream>\r\n#include <jsoncons/json.hpp>\r\n#include <jsoncons/json_filter.hpp>\r\n\r\nusing namespace jsoncons;\r\n\r\nint main()\r\n{\r\n    std::string s = R\"({\"first\":1,\"second\":2,\"fourth\":3,\"fifth\":4})\";    \r\n\r\n    json_serializer serializer(std::cout);\r\n\r\n    // Filters can be chained\r\n    rename_name_filter filter2(\"fifth\", \"fourth\", serializer);\r\n    rename_name_filter filter1(\"fourth\", \"third\", filter2);\r\n\r\n    // A filter can be passed to any function that takes\r\n    // a json_input_handler ...\r\n    std::cout << \"(1) \";\r\n    std::istringstream is(s);\r\n    json_reader reader(is, filter1);\r\n    reader.read();\r\n    std::cout << std::endl;\r\n\r\n    // or a json_output_handler    \r\n    std::cout << \"(2) \";\r\n    ojson j = ojson::parse(s);\r\n    j.write(filter1);\r\n    std::cout << std::endl;\r\n}\r\n```\r\nOutput:\r\n```json\r\n(1) {\"first\":1,\"second\":2,\"third\":3,\"fourth\":4}\r\n(2) {\"first\":1,\"second\":2,\"third\":3,\"fourth\":4}\r\n```\r\nOr define and use your own filters. See [json_filter](https://github.com/danielaparker/jsoncons/wiki/json_filter) for details.\r\n\r\n### JsonPath\r\n\r\n[Stefan Goessner's JsonPath](http://goessner.net/articles/JsonPath/) is an XPATH inspired query language for selecting parts of a JSON structure.\r\n\r\nHere is a sample JSON file (store.json):\r\n```json\r\n{ \"store\": {\r\n    \"book\": [ \r\n      { \"category\": \"reference\",\r\n        \"author\": \"Nigel Rees\",\r\n        \"title\": \"Sayings of the Century\",\r\n        \"price\": 8.95\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"Evelyn Waugh\",\r\n        \"title\": \"Sword of Honour\",\r\n        \"price\": 12.99\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"Herman Melville\",\r\n        \"title\": \"Moby Dick\",\r\n        \"isbn\": \"0-553-21311-3\",\r\n        \"price\": 8.99\r\n      },\r\n      { \"category\": \"fiction\",\r\n        \"author\": \"J. R. R. Tolkien\",\r\n        \"title\": \"The Lord of the Rings\",\r\n        \"isbn\": \"0-395-19395-8\",\r\n        \"price\": 22.99\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\nJsonPath examples:\r\n```c++    \r\n#include <jsoncons_ext/jsonpath/json_query.hpp>\r\n\r\nusing jsoncons::jsonpath::json_query;\r\n\r\njson root = json::parse_file(\"store.json\");\r\n\r\n// The authors of books that are cheaper than $10\r\njson result1 = json_query(booklist, \"$.store.book[?(@.price < 10)].author\");\r\nstd::cout << \"(1) \" << result1 << std::endl;\r\n\r\n// The number of books\r\njson result2 = json_query(booklist, \"$..book.length\");\r\nstd::cout << \"(2) \" << result2 << std::endl;\r\n\r\n// The third book\r\njson result3 = json_query(booklist, \"$..book[2]\");\r\nstd::cout << \"(3)\\n\" << pretty_print(result3) << std::endl;\r\n\r\n// All books whose author's name starts with Evelyn\r\njson result4 = json_query(booklist, \"$.store.book[?(@.author =~ /Evelyn.*?/)]\");\r\nstd::cout << \"(4)\\n\" << pretty_print(result4) << std::endl;\r\n\r\n// The titles of all books that have isbn number\r\njson result5 = json_query(booklist, \"$..book[?(@.isbn)].title\");\r\nstd::cout << \"(5) \" << result5 << std::endl;\r\n\r\n// All authors and titles of books\r\njson result6 = json_query(booklist, \"$['store']['book']..['author','title']\");\r\nstd::cout << \"(6)\\n\" << pretty_print(result6) << std::endl;\r\n```\r\nOutput:\r\n```json\r\n(1) [\"Nigel Rees\",\"Herman Melville\"]\r\n(2) [4]\r\n(3)\r\n[\r\n    {\r\n        \"author\": \"Herman Melville\",\r\n        \"category\": \"fiction\",\r\n        \"isbn\": \"0-553-21311-3\",\r\n        \"price\": 8.99,\r\n        \"title\": \"Moby Dick\"\r\n    }\r\n]\r\n(4)\r\n[\r\n    {\r\n        \"author\": \"Evelyn Waugh\",\r\n        \"category\": \"fiction\",\r\n        \"price\": 12.99,\r\n        \"title\": \"Sword of Honour\"\r\n    }\r\n]\r\n(5) [\"Moby Dick\",\"The Lord of the Rings\"]\r\n(6)\r\n[\r\n    \"Nigel Rees\",\r\n    \"Sayings of the Century\",\r\n    \"Evelyn Waugh\",\r\n    \"Sword of Honour\",\r\n    \"Herman Melville\",\r\n    \"Moby Dick\",\r\n    \"J. R. R. Tolkien\",\r\n    \"The Lord of the Rings\"\r\n]\r\n```\r\n### About jsoncons::json\r\n\r\nThe [json](https://github.com/danielaparker/jsoncons/wiki/json) class is an instantiation of the `basic_json` class template that uses `char` as the character type\r\nand sorts object members in alphabetically order.\r\n```c++\r\ntypedef basic_json<char,\r\n                   JsonTraits = json_traits<char>,\r\n                   Allocator = std::allocator<char>> json;\r\n```\r\nIf you prefer to retain the original insertion order, use [ojson](https://github.com/danielaparker/jsoncons/wiki/ojson) instead.\r\n\r\nThe library includes an instantiation for wide characters as well, [wjson](https://github.com/danielaparker/jsoncons/wiki/wjson)\r\n```c++\r\ntypedef basic_json<wchar_t,\r\n                   JsonTraits = json_traits<wchar_t>,\r\n                   Allocator = std::allocator<wchar_t>> wjson;\r\n```\r\nIf you prefer to retain the original insertion order, use [owjson](https://github.com/danielaparker/jsoncons/wiki/owjson) instead.\r\n\r\nNote that the allocator type allows you to supply a custom allocator. For example, you can use the boost [fast_pool_allocator](http://www.boost.org/doc/libs/1_60_0/libs/pool/doc/html/boost/fast_pool_allocator.html):\r\n```c++\r\n#include <boost/pool/pool_alloc.hpp>\r\n#include <jsoncons/json.hpp>\r\n\r\ntypedef jsoncons::basic_json<char, boost::fast_pool_allocator<char>> myjson;\r\n\r\nmyjson o;\r\n\r\no.set(\"FirstName\",\"Joe\");\r\no.set(\"LastName\",\"Smith\");\r\n```\r\nThis results in a json value being constucted with all memory being allocated from the boost memory pool. (In this particular case there is no improvement in performance over `std::allocator`.)\r\n\r\nNote that the underlying memory pool used by the `boost::fast_pool_allocator` is never freed. \r\n\r\n### Wide character support\r\n\r\njsoncons supports wide character strings and streams with `wjson` and `wjson_reader`. It supports `UTF16` encoding if `wchar_t` has size 2 (Windows) and `UTF32` encoding if `wchar_t` has size 4. You can construct a `wjson` value in exactly the same way as a `json` value, for instance:\r\n```c++\r\nusing jsoncons::wjson;\r\n\r\nwjson root;\r\nroot[L\"field1\"] = L\"test\";\r\nroot[L\"field2\"] = 3.9;\r\nroot[L\"field3\"] = true;\r\n\r\nstd::wcout << root << L\"\\n\";\r\n```\r\nwhich prints\r\n```c++\r\n{\"field1\":\"test\",\"field2\":3.9,\"field3\":true}\r\n```\r\n### ojson and owjson\r\n\r\nThe [ojson](https://github.com/danielaparker/jsoncons/wiki/ojson) ([owjson](https://github.com/danielaparker/jsoncons/wiki/owjson)) class is an instantiation of the `basic_json` class template that uses `char` (`wchar_t`) as the character type and keeps object members in their original order. \r\n```c++\r\nojson o = ojson::parse(R\"(\r\n{\r\n    \"street_number\" : \"100\",\r\n    \"street_name\" : \"Queen St W\",\r\n    \"city\" : \"Toronto\",\r\n    \"country\" : \"Canada\"\r\n}\r\n)\");\r\n\r\nstd::cout << pretty_print(o) << std::endl;\r\n```\r\nOutput:\r\n```json\r\n{\r\n    \"street_number\": \"100\",\r\n    \"street_name\": \"Queen St W\",\r\n    \"city\": \"Toronto\",\r\n    \"country\": \"Canada\"\r\n}\r\n```\r\nInsert \"postal_code\" at end\r\n```c++\r\no.set(\"postal_code\", \"M5H 2N2\");\r\n\r\nstd::cout << pretty_print(o) << std::endl;\r\n```\r\nOutput:\r\n```json\r\n{\r\n    \"street_number\": \"100\",\r\n    \"street_name\": \"Queen St W\",\r\n    \"city\": \"Toronto\",\r\n    \"country\": \"Canada\",\r\n    \"postal_code\": \"M5H 2N2\"\r\n}\r\n```\r\nInsert \"province\" before \"country\"\r\n```c++\r\nauto it = o.find(\"country\");\r\no.set(it,\"province\",\"Ontario\");\r\n\r\nstd::cout << pretty_print(o) << std::endl;\r\n```\r\nOutput:\r\n```json\r\n{\r\n    \"street_number\": \"100\",\r\n    \"street_name\": \"Queen St W\",\r\n    \"city\": \"Toronto\",\r\n    \"province\": \"Ontario\",\r\n    \"country\": \"Canada\",\r\n    \"postal_code\": \"M5H 2N2\"\r\n}\r\n```\r\n\r\n### Convert `json` to/from user defined type\r\n\r\nIn the json class, constructors, accessors and modifiers are templated, for example,\r\n```c++\r\ntemplate <class T>\r\njson(const T& val)\r\n\r\ntemplate<class T>\r\nbool is() const\r\n\r\ntemplate<class T>\r\nT as() const\r\n\r\ntemplate <class T>\r\nbasic_json& operator=(const T& val)\r\n\r\ntemplate <class T>\r\nvoid add(const T& val)\r\n```\r\nThe implementations of these functions and operators make use of the class template `json_type_traits`\r\n\r\nThis `json_type_traits` template is extensible, you, the user, can extend `json_type_traits` in the `jsoncons` namespace with your own types. \r\nFor example, you can provide a specialization of `json_type_traits` for a `book` class, and then transfer book objects or\r\nstandard library collections of book objects to and from `json` values.\r\n\r\n```c++\r\nstruct book\r\n{\r\n    std::string author;\r\n    std::string title;\r\n    double price;\r\n};\r\n\r\nnamespace jsoncons\r\n{\r\n    template<class Json>\r\n    struct json_type_traits<Json, book>\r\n    {\r\n        static bool is(const Json& rhs) noexcept\r\n        {\r\n            return rhs.is_object() &&\r\n                   rhs.has_key(\"author\") && \r\n                   rhs.has_key(\"title\") && \r\n                   rhs.has_key(\"price\");\r\n        }\r\n        static book as(const Json& rhs)\r\n        {\r\n            book val;\r\n            val.author = rhs[\"author\"]. template as<std::string>();\r\n            val.title = rhs[\"title\"]. template as<std::string>();\r\n            val.price = rhs[\"price\"]. template as<double>();\r\n            return val;\r\n        }\r\n        static Json to_json(const book& val)\r\n        {\r\n            Json j;\r\n            j[\"author\"] = val.author;\r\n            j[\"title\"] = val.title;\r\n            j[\"price\"] = val.price;\r\n            return j;\r\n        }\r\n    };\r\n};\r\n\r\nint main()\r\n{\r\n    book book1{\"Haruki Murakami\", \"Kafka on the Shore\", 25.17};\r\n\r\n    json j = book1;\r\n\r\n    std::cout << \"(1) \" << std::boolalpha << j.is<book>() << \"\\n\\n\";\r\n\r\n    std::cout << \"(2) \" << pretty_print(j) << \"\\n\\n\";\r\n\r\n    book temp = j.as<book>();\r\n    std::cout << \"(3) \" << temp.author << \",\" \r\n                        << temp.title << \",\" \r\n                        << temp.price << \"\\n\\n\";\r\n\r\n    book book2{\"Charles Bukowski\", \"Women: A Novel\", 12.0};\r\n\r\n    std::vector<book> book_array{book1, book2};\r\n\r\n    json ja = book_array;\r\n\r\n    std::cout << \"(4) \" << std::boolalpha \r\n                        << ja.is<std::vector<book>>() << \"\\n\\n\";\r\n\r\n    std::cout << \"(5)\\n\" << pretty_print(ja) << \"\\n\\n\";\r\n\r\n    auto book_list = ja.as<std::list<book>>();\r\n\r\n    std::cout << \"(6)\" << std::endl;\r\n    for (auto b : book_list)\r\n    {\r\n        std::cout << b.author << \", \" \r\n                  << b.title << \", \" \r\n                  << b.price << std::endl;\r\n    }\r\n}\r\n``` \r\nOutput:\r\n```\r\n(1) true\r\n\r\n(2) {\r\n    \"author\": \"Haruki Murakami\",\r\n    \"price\": 25.17,\r\n    \"title\": \"Kafka on the Shore\"\r\n}\r\n\r\n(3) Haruki Murakami,Kafka on the Shore,25.17\r\n\r\n(4) true\r\n\r\n(5)\r\n[\r\n    {\r\n        \"author\": \"Haruki Murakami\",\r\n        \"price\": 25.17,\r\n        \"title\": \"Kafka on the Shore\"\r\n    },\r\n    {\r\n        \"author\": \"Charles Bukowski\",\r\n        \"price\": 12.0,\r\n        \"title\": \"Women: A Novel\"\r\n    }\r\n]\r\n\r\n(6)\r\nHaruki Murakami, Kafka on the Shore, 25.17\r\nCharles Bukowski, Women: A Novel, 12\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}